# shape_from_metric
这次提交的代码主要在运行速度上有一定提升，以max_iteration=60次为例，大约需要68s，为之前的60%。
除此之外还加入了一个一个名为torus.m的文件。用来重现作者的展示的关于torus的例子。

%%%%%%%%%%%%%%%%%%%%%pre
这次提交的代码主要在运行速度上有一定提升，以max_iteration=60次为例，大约需要112s，大约为之前的30%。
除此之外，里面还有一个non_unique.m文件。主要是展示解的不唯一性。
这次还加了一个obj模型的压缩包，大概看名字就知道是什么了。就是同一类型有多个，想要区分还是需要打开看看。
当然还有一些其它次要更改就不细说了。

%%%%%%%%%%%%%%%%%%%%pre
这是作者提供的第一个例子的matlab版本的代码，即BunnyFromMetric.
作者提供的这个例子是所有例子中最基础的。例如后面对于存在边界的模型又要进行其它处理。不过核心算法还是有的，所以主要是用来对照论文的,如果要实现其它例子也只需以此为框架。
要运行此代码只需打开main.m运行即可，最后代码所在文件夹会有一个obj文件输出，即为结果，也会画出图来。核心算法则在BunnyFromMetric函数中，可以调整的参数有最大迭代次数(预设60)，边的长度和拓扑结构。这个函数目前虽然在Bunny上运行结果较好，但是如果使用其它的模型则可能无法取得满意的结果。
大概有这几个原因。首先是步长(dt)和论文中的μ是需要预设的。对于不同的情形这值应该是不同的。比如对于一个球面(sphere.obj)来说，设置max_iteration=20可以得到看起来不错的结果，设成60则结果看起来不太好。这是因为ε随迭代次数而改变，后面的ε使结果看起来不好。但事实上l2_rel_err等误差更小。这也是第二点原因，不唯一性，即在所有边长已知的情况下，可能的结果不唯一。即使一个四面体也可以通过镜像对称得到另一个可能的结果。所以会有一些与输入完全不符且看起来很糟糕的结果但是l2_rel_err等误差却不大的情况出现。
至于运行速度方面，虽然删了不少步骤，但是速度依然没什么提升。以max_iteration=60次为例，上次用了384s，这次用了371s，提升不足5%.而其中solver即迭代过程占用了99%以上的时间。在这其中矩阵乘法，解方程和极分解三部分用时320秒。但是每一步都是必不可少的，也没有想到缩短时间的方法。
